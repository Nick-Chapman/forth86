
# Down the Forth Rabbit Hole

I have recently stumbled down the Forth Rabbit hole. It's been an enjoyable few weeks. I seem to rediscover Forth and it's concatenative cousins every decade of my career. Have a bit of a dabble and move on. But this time I went deep.

I implemented my own Forth system. As you do. [Quarter Forth](https://github.com/Nick-Chapman/quarter-forth). Initially following Virgil Dupras' excellent [Tumble forth tutorial](https://tumbleforth.hardcoded.net) which taught me details of the _x86_ architecture and boot process. I was very keen to explore implementation from the ground up; using a high level language (for example Haskell, my favorite) didn't seem to really embrace the spirit of Forth which I was learning about.

Initially I was concerned that by implementing my own Forth system, although fun and instructive, I still wouldn't _get_ the essence of Forth, as that would require coding _in_ Forth. But soon I realized this worry was not well founded. Implementing a Forth system requires writing _lots_ of Forth code. To begin with (following the tutorial) everything was in x86 Asm. But as my system grew, I started implementing more and more in Forth itself. This is probably obvious to any die-hard Forth-ist! But I had to discover it myself.

### Self Hosting

There is something glorious about seeing how much of Forth can be implemented in itself. Perhaps the first step of this _self-hosting_ joy is when you see how the `if`/`then` control structures are not special builtins, but just standard Forth words, marked as `immediate` so they act like macros at compile time. The following definitions suffice in Quarter Forth:

```
: if
['] 0branch compile, here 0 ,
; immediate

: then
dup here swap - swap !
; immediate
```

TODO: explain

Even comment handling does not have to be builtin, but can be defined in Forth itself. For example, the following definition will provide basic support:

```
: (
key [char] ) = if exit then recurse
; immediate

( Woo hoo. Now we have comments )
```

TODO: explain

In _Quarter Forth_, the disassembler (`see`) and memory dump tools (`dump`/`xxd`) are written in Forth, and were for me quite substantial pieces of code to develop. Also implemented within Forth is a basic system for buffered line input, with support for backspace editing no less! But even as I was working/struggling to implement these Forth applications, I knew how much harder it would be to work at the level of x86 Asm.

Of course, the other application which can be implemented within Forth is the Forth text interpreter itself...

### Next Time

In the [next article](2.bootstrap.md)

- We explore how to implement the Forth text interpreter in Forth.
- See why this is a good idea.
- Deal with the bootstrapping issue into which we run.
