
# Down the Forth Rabbit Hole

I have recently stumbled down the Forth Rabbit hole. It's been an enjoyable few weeks. I seem to rediscover Forth and it's concatenative cousins every decade of my career, ave a bit of a dabble and move on. But this time I went deep.

I implemented my own Forth system. As you do. [Quarter Forth](https://github.com/Nick-Chapman/quarter-forth). Initially following Virgil Dupras' excellent [Tumble forth tutorial](https://tumbleforth.hardcoded.net) which taught me details of the _x86_ architecture and boot process. I was very keen to explore implementation from the ground up: Using a high level language (for example Haskell, my favorite) doesn't seem to really embrace the spirit of Forth I was learning about.

Initially I was concerned that by implementing my own Forth system, although fun and instructive, I wouldn't _get_ the essence of Forth -- that would require coding _in_ Forth. But soon I realized this worry was not well founded. Implementing a Forth system requires writing _lots_ of Forth code. To begin with (following the tutorial) everything was in x86 Asm. But as my system grew, I started implementing more and more in Forth itself. This is probably obvious to any die-hard Forth-ist! But I had to discover it myself.

### Self Hosting

There is something glorious about seeing how much of Forth can be implemented within itself. Perhaps the first step of this _self-hosting_ joy is when you see how the `if`/`then` control structures are not special builtins, but just standard Forth words. They are marked as `immediate` so they act like macros and run at compile time. The following definitions suffice in Quarter Forth:

```
: if
['] 0branch compile, here 0 ,
; immediate

: then
dup here swap - swap !
; immediate
```

The `if` and `then` words are run during the compilation of a word which uses them. They work together to generate code (`0branch`) which conditionally branches over the sequence of words between `if` and `then`. (We will see this below in an example) The `0branch` word and the immediately following _destination_ slot is generated by `if`. The destination slot gets _backpatched_ by `then` which will know the target of the branch. The location of the slot to be backpatched is left on the stack at compile time; left by `if`, and consumed by `then`, which computes the relative offset, as required by `0branch`, and patches the dummy `0` value initially written there by `if`. Phew!


Another example of self hosting is comment handling. Again, it does not have to be builtin, but can be defined in Forth itself. For example, the following definition will provide basic support:

```
: (
key [char] ) = if exit then recurse
; immediate

( Woo hoo. Now we have comments )
```

The definition of `(` skips all following input characters, obtained via `key`, until a closing `)` is encountered; `if` and `then` generate the code which will conditionally skip over the call to `exit`. The looping structure is setup with `recurse` which tail-calls the current definition (`(`). This is little unconventional; standard Forth would use `begin`/`again` looping words.

With just a little more work we can define comments which properly nest by counting the opening and closing parenthesis while skipping. We can also implement useful features like string literals (`.s"` ... `"`) all within Forth itself. See [forth.f](https://github.com/Nick-Chapman/quarter-forth/blob/main/f/forth.f) for details.

In _Quarter Forth_, the disassembler (`see`) and memory dump tools (`dump`/`xxd`) are written in Forth, and were for me quite substantial pieces of code to develop. Also implemented within Forth is a basic system for buffered line input, with support for backspace editing no less! But even as I was working/struggling to implement these Forth applications, I knew how much harder it would be to work at the level of x86 Asm.

Of course, the other application which can be implemented within Forth is the Forth text interpreter itself...

### Next Time

In the [next article](2.bootstrap.md)

- We implement the Forth text interpreter in Forth.
- See why this is a good idea.
- Deal with the bootstrapping issue into which we run.
